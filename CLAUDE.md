# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Core Concept: The zsh for Claude Code

**Memento Protocol is to Claude Code what zsh is to bash.** We enhance, customize, and empower Claude Code through themes (modes), plugins (agents/workflows), configuration (.memento/config), and automation (hooks). Think of this project as building oh-my-zsh for AI development.

## Important: Dogfooding Context

We are dogfooding Memento Protocol while developing it. This means:
- The **generator CLI source code** (src/, scripts/, templates/) is what we're developing
- The **generated .memento directory** contains our own project's modes/workflows/tickets
- The **generated .claude directory** contains Claude Code configuration generated by our CLI
- When making updates, always modify the CLI source code, then run `npm run dev init -- --force --non-interactive` to update our own dogfooding setup

**NEVER** confuse:
- Editing the CLI code (what we want) vs editing generated files (usually wrong)
- The Memento Protocol CLI commands vs Claude Code custom commands
- Templates in templates/ (source) vs installed components in .memento/ (generated)

### Dogfooding Guide

When making changes to Memento Protocol:

1. **After modifying templates**: Templates now use YAML frontmatter for metadata
   ```bash
   # Rebuild to regenerate metadata.json from frontmatter
   npm run build
   # Reinstall in our own project
   npm run dev init -- --force --non-interactive
   ```

2. **After adding new features**: Test them on our own project first
   ```bash
   # Use dev mode to test new commands
   npm run dev <command>
   # Example: npm run dev list
   ```

3. **After changing component discovery**: Verify components are found
   ```bash
   npm run dev list  # Should show all available components
   ```

4. **Template Frontmatter Format**: All templates are self-describing
   ```yaml
   ---
   name: component-name
   description: What this component does
   author: memento-protocol  
   version: 1.0.0
   tags: [tag1, tag2]
   ---
   # Component content here
   ```

## Commands

### Build and Development
```bash
# Install dependencies
npm install

# Validate dependencies and build the project (bundles with esbuild, adds shebang, copies templates)
npm run build

# Development mode (run TypeScript directly)
npm run dev

# Watch mode for development
npm run watch

# Validate dependencies without building
npm run validate

# Clean build artifacts
npm run clean
```

### Testing
```bash
# Run all tests
npm test

# Run tests with coverage (thresholds: 30% branches, 45% functions/lines/statements)
npm run test:coverage

# Run a specific test file
npx jest src/commands/__tests__/init.test.ts

# Run tests matching a pattern
npx jest --testNamePattern="should create ticket"
```

### Publishing
```bash
# Prepare for publishing (runs tests and build)
npm run prepublishOnly

# The actual publish is handled by scripts/npm/commit-tag-and-publish.sh
```

## Development CLI

### Non-Interactive Initialization
- To run the current development CLI non-interactively: `yarn dev init --force --non-interactive`
- This regenerates our dogfooding .memento and .claude directories

## Architecture

### Core Structure
Memento Protocol is the "zsh for Claude Code" - a meta-framework that transforms Claude Code from a basic shell into a highly customizable power tool.

**Key Concepts (zsh Analogies):**
- **Modes**: AI personalities (like zsh themes - robbyrussell, agnoster, powerlevel10k)
- **Workflows**: Reusable procedures (like zsh functions/scripts)
- **Agents**: Specialized capabilities (like zsh plugins - git, docker, kubectl)
- **Tickets**: Persistent task tracking (like tmux sessions)
- **Hooks**: Automation points (like zsh hooks - precmd, preexec, chpwd)
- **Custom Commands**: Slash commands (like zsh aliases)
- **Fuzzy Matching**: Smart completions (like zsh's completion system)
- **.memento/config**: Project config (like .zshrc)

### Directory Layout
```
src/
├── cli.ts                 # Main entry point, command registration
├── commands/              # CLI command implementations
│   ├── init.ts           # Initialize/update Memento Protocol
│   ├── add.ts            # Add modes/workflows/agents
│   ├── list.ts           # List available/installed components
│   ├── ticket.ts         # Ticket management (create/move/resolve)
│   ├── config.ts         # Configuration management
│   ├── update.ts         # Update components
│   ├── upsert.ts         # Combined init/update logic
│   └── command.ts        # Claude Code custom command generator
└── lib/                  # Core functionality
    ├── configManager.ts  # Config hierarchy (default->global->project->env)
    ├── ticketManager.ts  # Ticket lifecycle management
    ├── componentInstaller.ts # Install modes/workflows/agents
    ├── commandGenerator.ts # Generate Claude Code custom commands
    ├── projectDetector.ts # Detect project language/framework
    ├── upsertManager.ts  # Smart init/update logic
    └── hooks/            # Hook system implementation
        ├── HookManager.ts # Main hook orchestrator
        ├── HookRegistry.ts # Hook registration system
        └── builtin/      # Built-in hooks (routing, security, etc.)

templates/                # Component templates
├── modes/               # Built-in modes (architect, engineer, etc.)
├── workflows/           # Built-in workflows (review, summarize, etc.)
├── agents/              # Claude Code subagents (claude-code-research)
├── hooks/               # Hook templates and scripts
├── scripts/             # Utility scripts (mode-switch, ticket-context)
└── metadata.json        # Component metadata

Generated Directories:
.memento/                # Project-specific Memento data
├── modes/              # Installed mode definitions
├── workflows/          # Installed workflow definitions
├── tickets/            # Ticket storage (next/in-progress/done)
├── hooks/              # Hook configurations and scripts
├── scripts/            # Generated utility scripts
└── config.json         # Project configuration

.claude/                 # Claude Code configuration
├── agents/             # Installed Claude Code agents
├── commands/           # Custom slash commands
│   ├── mode.md        # Mode switching command
│   ├── ticket.md      # Ticket management command
│   └── memento.md     # Memento status command
└── settings.local.json # Claude Code project settings
```

### Key Design Patterns

1. **Enhancement Philosophy**: Like zsh enhances bash, we enhance Claude Code without replacing it
2. **Plugin Architecture**: Components (modes/workflows/agents) work like zsh plugins - modular and composable
3. **Configuration Cascade**: Settings layer like zsh (defaults → global ~/.memento → project .memento → environment)
4. **Template System**: Components are templates that can be customized (like oh-my-zsh themes/plugins)
5. **Hook System**: Event-driven automation (like zsh's hook functions)
6. **Dual Directory Structure**: .memento/ (like ~/.oh-my-zsh/) and .claude/ (Claude Code integration)

### Build Process
The build uses esbuild (scripts/build.js) to:
1. Bundle TypeScript into a single CLI executable
2. Inject version from package.json
3. Add shebang for direct execution
4. Copy templates to dist directory

### Testing Strategy
- Uses Jest with ts-jest preset
- Mocks inquirer for interactive testing
- Coverage thresholds enforced
- Tests organized alongside source files in __tests__ directories

### Error Handling
- Custom error types in lib/errors.ts
- Global error handlers in cli.ts
- Verbose/debug logging options for troubleshooting

### Component System

#### Modes (Themes)
- AI personalities for different development tasks (like zsh themes change prompt appearance/behavior)
- Support fuzzy matching: exact match → substring → acronym (like zsh completions)
- Example: `apm` → `autonomous-project-manager` (like `gst` → `git status` in oh-my-zsh)
- Stored as markdown in .memento/modes/ (like themes in ~/.oh-my-zsh/themes/)
- Activated via `/mode [name]` custom command (like setting ZSH_THEME)

#### Workflows (Functions/Scripts)
- Reusable development procedures and patterns (like zsh functions)
- Stored as markdown in .memento/workflows/ (like custom functions in .zshrc)
- Can be referenced in prompts or modes (like calling functions in zsh)

#### Agents (Plugins)
- Claude Code subagents for specialized tasks (like zsh plugins add specific capabilities)
- Installed to .claude/agents/ directory (like plugins in ~/.oh-my-zsh/plugins/)
- Example: claude-code-research agent (like the 'git' plugin in oh-my-zsh)
- Added via `memento add agent [name]` (like adding plugins to .zshrc)

#### Hooks (Event Functions)
- Claude Code integration points for automated behavior (like zsh hook functions)
- Built-in hooks:
  - memento-routing (like preexec - runs before commands)
  - project-overview (like chpwd - runs on directory change)
  - git-context-loader (like precmd - runs before prompts)
  - acronym-expander (like alias expansion)
- Custom hooks can be added (like adding custom hook functions)
- Configured in .memento/hooks/definitions/

#### Custom Commands
- Project-specific slash commands generated in .claude/commands/
- `/mode` - Switch between modes with fuzzy matching
- `/ticket` - Manage tickets and load context
- `/memento` - Show project status

### Ticket Workflow
Tickets follow a lifecycle:
1. Created in `.memento/tickets/next/`
2. Moved to `.memento/tickets/in-progress/` when started
3. Moved to `.memento/tickets/done/` when completed
4. Can include context that gets injected into CLAUDE.md

## Development Guidelines

### Adding New Commands
1. Create command file in `src/commands/`
2. Export a Command instance
3. Register in `src/cli.ts`
4. Add tests in `src/commands/__tests__/`

### Adding New Components
1. Create template in appropriate `templates/` subdirectory:
   - Modes: markdown with personality/behavior instructions
   - Workflows: markdown with step-by-step procedures
   - Agents: markdown with frontmatter for tools and description
   - Hooks: JSON definition + shell script implementation
2. Update metadata.json with component metadata
3. Test installation via CLI commands
4. For agents, ensure proper .claude/agents/ targeting

### Adding New Starter Packs
1. Create pack definition in `templates/starter-packs/[pack-name].json`:
   ```json
   {
     "name": "pack-name",
     "version": "1.0.0", 
     "description": "Pack description",
     "author": "author-name",
     "category": "frontend|backend|fullstack|devops|mobile|ai-ml|data|general",
     "components": {
       "modes": [{ "name": "mode-name", "required": true }],
       "workflows": [{ "name": "workflow-name", "required": false }],
       "agents": [{ "name": "agent-name", "required": false }]
     }
   }
   ```
2. Validate against schema: `templates/starter-packs/schema.json`
3. Test pack loading and installation
4. Ensure all referenced components exist in templates
5. Add to available packs documentation

### Hook Development
1. Create hook definition JSON in templates/hooks/
2. Create corresponding shell script
3. Define trigger events and configuration options
4. Test with real Claude Code interactions

### StarterPackManager API
The `StarterPackManager` class handles pack operations:

```typescript
import { StarterPackManager } from '../lib/StarterPackManager';

const manager = new StarterPackManager(projectRoot);

// List available packs
const packs = await manager.listPacks();

// Load specific pack
const pack = await manager.loadPack('frontend-react');

// Validate pack definition
const validation = await manager.validatePack(packData);

// Resolve dependencies
const deps = await manager.resolveDependencies(pack);

// Install pack (Phase 2 - currently stub)
const result = await manager.installPack(pack, { force: true });
```

**Key Features:**
- JSON schema validation against `templates/starter-packs/schema.json`
- Component reference validation (ensures modes/workflows/agents exist)
- Dependency resolution with circular dependency detection
- Installation simulation (actual installation in Phase 2)

### Testing Guidelines for Starter Packs
1. **Schema Validation**: Test pack definitions against JSON schema
2. **Component References**: Ensure all referenced components exist
3. **Dependency Resolution**: Test dependency chains and circular detection
4. **Installation Simulation**: Verify pack installation logic
5. **Error Handling**: Test invalid packs, missing components, conflicts

Example test structure:
```typescript
describe('StarterPackManager', () => {
  it('should load valid pack', async () => {
    const pack = await manager.loadPack('frontend-react');
    expect(pack.name).toBe('frontend-react');
  });

  it('should validate pack schema', async () => {
    const result = await manager.validatePack(validPackData);
    expect(result.valid).toBe(true);
  });
});
```

### Code Style
- TypeScript with strict mode
- CommonJS modules for Node.js compatibility
- Async/await for asynchronous operations
- Comprehensive error messages for CLI users

### Dependencies
- commander: CLI framework
- inquirer: Interactive prompts
- esbuild: Build tool
- jest/ts-jest: Testing framework
- ajv: JSON schema validation for starter packs

## Recent Enhancements

### The zsh Philosophy Implementation
- **Fuzzy Matching**: Like zsh's smart completions (`eng` → `engineer`, `apm` → `autonomous-project-manager`)
- **Plugin System**: Agents work like zsh plugins - modular, focused, composable
- **Theme System**: Modes are like themes - completely change behavior/personality
- **Configuration Hierarchy**: Like zsh's config loading (defaults → global → project → env)
- **Hook System**: Event-driven automation like zsh hooks (precmd, preexec, chpwd)
- **Alias System**: Custom commands work like zsh aliases

### Starter Packs System
- **Current**: Functional pack loading, validation, and dependency resolution
- **JSON Schema**: Complete validation with component reference checking
- **Available Packs**: `frontend-react` pack with React development setup
- **Management**: StarterPackManager handles installation and dependencies

### Coming Soon (oh-my-memento)
- **More Packs**: Backend API, DevOps, Data Science starter packs
- **~/.memento/config.yaml**: Global config file (unified structure with project config)
- **Community Hub**: Share modes/workflows (like awesome-zsh-plugins)
- **Plugin Manager**: Easy installation/updates (like zplug, zinit)
- **Visual Configurator**: GUI setup (like zsh configuration tools)